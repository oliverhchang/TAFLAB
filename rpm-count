const int hallPin = 2;  // Connect S (signal) pin here
volatile unsigned int pulseCount = 0;

unsigned long lastMeasureTime = 0;
const unsigned long interval = 100; // 100ms = 10 measurements per second

// Rolling average for smoother readings
const int numReadings = 10;  // Average over last 10 readings (1 second)
int readings[numReadings];   // Array to store readings
int readIndex = 0;           // Current position in array
int total = 0;               // Running total
int averageRPM = 0;          // Averaged RPM

// Variables for edge detection
volatile bool lastState = HIGH;
volatile unsigned long lastStateChangeTime = 0;
const unsigned long minPulseWidth = 5; // Reduced to 5ms for high RPM

void setup() {
  Serial.begin(115200); // Higher baud rate for more data
  pinMode(hallPin, INPUT);
  
  // Initialize all readings to 0
  for (int i = 0; i < numReadings; i++) {
    readings[i] = 0;
  }
  
  // Use CHANGE to detect both rising and falling edges
  attachInterrupt(digitalPinToInterrupt(hallPin), detectMagnet, CHANGE);
  
  Serial.println("High-Frequency Hall Sensor RPM Monitor Started");
  Serial.println("Measurement interval: 100ms | Rolling average: 10 samples");
  Serial.println("Time(ms), Instant_RPM, Avg_RPM, Pulses");
}

void loop() {
  unsigned long now = millis();

  if (now - lastMeasureTime >= interval) {
    // Disable interrupts while reading volatile variable
    noInterrupts();
    unsigned int currentPulseCount = pulseCount;
    pulseCount = 0; // Reset counter for next interval
    interrupts();
    
    // Calculate instantaneous RPM
    // pulses in 100ms * 10 = pulses per second * 60 = pulses per minute
    unsigned int instantRPM = currentPulseCount * 600;
    
    // Update rolling average
    total = total - readings[readIndex];        // Remove oldest reading
    readings[readIndex] = instantRPM;           // Add new reading
    total = total + readings[readIndex];        // Add new reading to total
    readIndex = (readIndex + 1) % numReadings;  // Move to next position
    averageRPM = total / numReadings;           // Calculate average
    
    // Output data in CSV format for easy analysis
    Serial.print(now);
    Serial.print(", ");
    Serial.print(instantRPM);
    Serial.print(", ");
    Serial.print(averageRPM);
    Serial.print(", ");
    Serial.println(currentPulseCount);

    lastMeasureTime = now;
  }
}

void detectMagnet() {
  unsigned long currentTime = millis();
  bool currentState = digitalRead(hallPin);
  
  // Debounce: ignore changes that happen too quickly
  if (currentTime - lastStateChangeTime < minPulseWidth) {
    return;
  }
  
  // Count a pulse when sensor goes from HIGH to LOW (magnet detected)
  if (lastState == HIGH && currentState == LOW) {
    pulseCount++;
  }
  
  lastState = currentState;
  lastStateChangeTime = currentTime;
}
