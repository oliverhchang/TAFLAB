const int hallPin = 2;
volatile unsigned long lastPulseTime = 0;
volatile unsigned long pulseInterval = 0;
volatile bool newPulseReceived = false;
volatile unsigned int pulseCount = 0;

// Method selection - change this to try different approaches
#define USE_PULSE_TIMING 1  // 1 = pulse timing method, 0 = frequency counting

#if USE_PULSE_TIMING
// Pulse timing method - measures time between pulses
unsigned long lastDisplayTime = 0;
const unsigned long displayInterval = 100; // Display every 100ms
float currentRPM = 0;

// Rolling average for smoother readings
const int numReadings = 5;
float readings[numReadings];
int readIndex = 0;
float total = 0;
float averageRPM = 0;

#else
// Frequency counting method - shorter intervals
unsigned long lastMeasureTime = 0;
const unsigned long interval = 100; // 100ms intervals
const int numReadings = 10;
int readings[numReadings];
int readIndex = 0;
int total = 0;
int averageRPM = 0;
#endif

// Edge detection variables
volatile bool lastState = HIGH;
volatile unsigned long lastStateChangeTime = 0;
const unsigned long minPulseWidth = 5;

void setup() {
  Serial.begin(9600);
  pinMode(hallPin, INPUT);
  
#if USE_PULSE_TIMING
  // Initialize readings array
  for (int i = 0; i < numReadings; i++) {
    readings[i] = 0;
  }
  Serial.println("High-Precision RPM Monitor - Pulse Timing Method");
  Serial.println("Measures time between individual pulses for precision");
#else
  // Initialize readings array
  for (int i = 0; i < numReadings; i++) {
    readings[i] = 0;
  }
  Serial.println("High-Precision RPM Monitor - High Frequency Method");
  Serial.println("100ms intervals with 10-sample rolling average");
#endif
  
  attachInterrupt(digitalPinToInterrupt(hallPin), detectMagnet, CHANGE);
  Serial.println("Ready...");
  delay(1000);
}

void loop() {
#if USE_PULSE_TIMING
  // Pulse timing method - calculate RPM from time between pulses
  unsigned long now = millis();
  
  if (newPulseReceived && pulseInterval > 0) {
    newPulseReceived = false;
    
    // Calculate RPM from pulse interval
    // RPM = 60,000ms / interval_in_ms
    currentRPM = 60000.0 / pulseInterval;
    
    // Update rolling average
    total = total - readings[readIndex];
    readings[readIndex] = currentRPM;
    total = total + readings[readIndex];
    readIndex = (readIndex + 1) % numReadings;
    averageRPM = total / numReadings;
  }
  
  // Display results every 100ms
  if (now - lastDisplayTime >= displayInterval) {
    Serial.print("RPM: ");
    Serial.print(currentRPM, 1); // 1 decimal place
    Serial.print(" | Avg: ");
    Serial.print(averageRPM, 1);
    Serial.print(" | Interval: ");
    Serial.print(pulseInterval);
    Serial.println("ms");
    
    lastDisplayTime = now;
    
    // Reset if no pulse for 2 seconds (stopped)
    if (now - lastPulseTime > 2000) {
      currentRPM = 0;
      averageRPM = 0;
      for (int i = 0; i < numReadings; i++) {
        readings[i] = 0;
      }
      total = 0;
    }
  }
  
#else
  // High frequency counting method
  unsigned long now = millis();
  
  if (now - lastMeasureTime >= interval) {
    cli();
    unsigned int currentPulseCount = pulseCount;
    pulseCount = 0;
    sei();
    
    // Calculate RPM: pulses in 100ms * 10 = pulses/sec * 60 = RPM
    unsigned int instantRPM = currentPulseCount * 600;
    
    // Update rolling average
    total = total - readings[readIndex];
    readings[readIndex] = instantRPM;
    total = total + readings[readIndex];
    readIndex = (readIndex + 1) % numReadings;
    averageRPM = total / numReadings;
    
    Serial.print("RPM: ");
    Serial.print(instantRPM);
    Serial.print(" | Avg: ");
    Serial.print(averageRPM);
    Serial.print(" | Pulses: ");
    Serial.println(currentPulseCount);
    
    lastMeasureTime = now;
  }
#endif
}

void detectMagnet() {
  unsigned long currentTime = millis();
  bool currentState = digitalRead(hallPin);
  
  if (currentTime - lastStateChangeTime < minPulseWidth) {
    return;
  }
  
  if (lastState == HIGH && currentState == LOW) {
#if USE_PULSE_TIMING
    // Calculate interval between pulses
    if (lastPulseTime > 0) {
      pulseInterval = currentTime - lastPulseTime;
      newPulseReceived = true;
    }
    lastPulseTime = currentTime;
#else
    pulseCount++;
#endif
  }
  
  lastState = currentState;
  lastStateChangeTime = currentTime;
}
